<!DOCTYPE html>

<html lang="en">
<head>
<title>Web VR Polyfill - basic example</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0, shrink-to-fit=no">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<style>
html, body {
  width: 100%;
  height: 100%;
  background-color: #000;
  color: #fff;
  margin: 0px;
  padding: 0;
  overflow: hidden;
}

canvas {
  position: absolute;
  top: 0;
}

#buttons {
  position: fixed;
  top: 0;
  right: 0;
  z-index: 1;
  background: white;
}

            #menu {
                position: absolute;
                width: 200px;
                height: 250px;

                top: 50%; left: 50%;
                margin: -125px 0 0 -100px;

                text-align: center;

                border: 3px solid #fff;
                border-radius: 15px;

                background-color: #E36B23;
                box-shadow: 2px 10px 5px #888;
            }

            #menu p {font-weight: bold; color: #fff;}
            #menu p a {color: #fff;}

            #menu button {
                width: 80px;
                height: 25px;

                background-color: #C44032;

                border: 3px solid #fff;
                border-radius: 5px;

                font-size: 14px;
                font-weight: bold;
                color: #fff;
            }

            #points {
                position: absolute;
                width: 120px;
                height: 16px;

                padding: 12px;

                top: 20px;
                right: 80px;

                border: 3px solid #fff;
                border-radius: 15px;

                background-color: #E36B23;
                box-shadow: 2px 10px 5px #888;

                font-size: 14px;
                font-weight: bold;
                color: #fff;

                text-align: right;

                display: none;
            }


</style>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/
</head>

<body>

        <audio id="audio_theme" src="music/tetris.mp3" preload="auto"></audio>
        <audio id="audio_move" src="music/move.mp3" preload="auto"></audio>
        <audio id="audio_collision" src="music/collision.mp3" preload="auto"></audio>
        <audio id="audio_gameover" src="music/gameover.mp3" preload="auto"></audio>
        <audio id="audio_score" src="music/cash.mp3" preload="auto"></audio>

  <div id="buttons">
    <button id="fullscreen">Fullscreen</button>
    <button id="vr">VR (WebVR/Mobile only)</button>
    <button id="reset">Reset</button>
	<button id="play_button">Play</button>
  </div>
  
          <div id="menu">
            <h1>WebVR Three.js Tetris</h1>
            <p>
              Movement: arrows<br>
              Rotation: AD/SW/QE<br>
              Author: BKL</a>
            </p>
<!-- moved Play button to "buttons" -->
        </div>
		
		<div id="points">
            0
        </div>

</body>

<script>
WebVRConfig = {
  BUFFER_SCALE: 1.0,
};

</script>

<!-- three.js library -->
 <script src="node_modules/three/build/three.js"></script>
<!-- VRControls.js applies the WebVR transformations to a three.js camera object. -->
<script src="node_modules/three/examples/js/controls/VRControls.js"></script>

<!-- VREffect.js handles stereo camera setup and rendering.  -->
<script src="node_modules/three/examples/js/effects/VREffect.js"></script>

<!-- A polyfill for the WebVR API.  -->
<script src="../../build/webvr-polyfill.js"></script>

        <script type="text/javascript" src="js/Stats.js"></script>
        <script type="text/javascript" src="js/tetris.board.js"></script>
        <script type="text/javascript" src="js/tetris.block.js"></script>
		<script src="js/cufon-yui.js" type="text/javascript"></script>
		<script src="js/Blox_400.font.js" type="text/javascript"></script>

        <script type="text/javascript">
//            Cufon.replace('#menu h1');
            Cufon.replace('#points');
        </script>		
				
		
<script>



//window = window || {};
window.Tetris = window.Tetris || {};
Tetris.sounds = {};

if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = ( function () {
        return window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            window.oRequestAnimationFrame ||
            window.msRequestAnimationFrame ||
            function (/* function FrameRequestCallback */ callback, /* DOMElement Element */ element) {
                window.setTimeout(callback, 1000 / 60);
            };
    })();
}

Tetris.init = function () {
    Tetris.sounds["theme"] = document.getElementById("audio_theme");  
    Tetris.sounds["collision"] = document.getElementById("audio_collision");  
    Tetris.sounds["move"] = document.getElementById("audio_move");  
    Tetris.sounds["gameover"] = document.getElementById("audio_gameover");  
    Tetris.sounds["score"] = document.getElementById("audio_score");  

    Tetris.sounds["theme"].play();
    // set the scene size
    var WIDTH = window.innerWidth,
        HEIGHT = window.innerHeight;

    // set some camera attributes
    var VIEW_ANGLE = 45,
        ASPECT = WIDTH / HEIGHT,
        NEAR = 0.1,
        FAR = 10000;

    // create a WebGL renderer, camera
    // and a scene
    Tetris.renderer = new THREE.WebGLRenderer();
    Tetris.camera = new THREE.PerspectiveCamera(VIEW_ANGLE,
        ASPECT,
        NEAR,
        FAR);
    Tetris.scene = new THREE.Scene();

    // the camera starts at 0,0,0 so pull it back
    Tetris.camera.position.z = 600;
    Tetris.scene.add(Tetris.camera);

    // start the renderer
    Tetris.renderer.setSize(WIDTH, HEIGHT);

    // attach the render-supplied DOM element
    document.body.appendChild(Tetris.renderer.domElement);

    // configuration object
    var boundingBoxConfig = {
        width:360,
        height:360,
        depth:1200,
        splitX:6,
        splitY:6,
        splitZ:20
    };
    Tetris.boundingBoxConfig = boundingBoxConfig;
    Tetris.blockSize = boundingBoxConfig.width / boundingBoxConfig.splitX;

    Tetris.Board.init(boundingBoxConfig.splitX, boundingBoxConfig.splitY, boundingBoxConfig.splitZ);

    var boundingBox = new THREE.Mesh(
        new THREE.CubeGeometry(boundingBoxConfig.width, boundingBoxConfig.height, boundingBoxConfig.depth, boundingBoxConfig.splitX, boundingBoxConfig.splitY, boundingBoxConfig.splitZ),
        new THREE.MeshBasicMaterial({ color:0xffaa00, wireframe:true })
    );
    Tetris.scene.add(boundingBox);

    Tetris.renderer.render(Tetris.scene, Tetris.camera);

    Tetris.stats = new Stats();
    Tetris.stats.domElement.style.position = 'absolute';
    Tetris.stats.domElement.style.top = '10px';
    Tetris.stats.domElement.style.left = '10px';
    document.body.appendChild(Tetris.stats.domElement);
	
    document.getElementById("play_button").addEventListener('click', function (event) {
        event.preventDefault();
        Tetris.start();
    });
};

	
	
Tetris.start = function () {
    document.getElementById("menu").style.display = "none";
    Tetris.pointsDOM = document.getElementById("points");
    Tetris.pointsDOM.style.display = "block";
	
    Tetris.sounds["theme"].pause();
	
    Tetris.Block.generate();
	
	//BKL 
	// Apply VR stereo rendering to renderer.
	Tetris.effect = new THREE.VREffect(Tetris.renderer);
	Tetris.effect.setSize(window.innerWidth, window.innerHeight);
	
	// Get the VRDisplay and save it for later.
	Tetris.vrDisplay = null;
	navigator.getVRDisplays().then(function(displays) {
	  if (displays.length > 0) {
		Tetris.vrDisplay = displays[0];

		// Kick off the render loop.
		Tetris.vrDisplay.requestAnimationFrame(Tetris.animate);
	  }
	});
    Tetris.animate();
};

Tetris.gameStepTime = 500;

Tetris.frameTime = 0; // ms
Tetris.cumulatedFrameTime = 0; // ms
Tetris._lastFrameTime = Date.now(); // timestamp

Tetris.gameOver = false;

Tetris.animate = function () {
    var time = Date.now();
    Tetris.frameTime = time - Tetris._lastFrameTime;
    Tetris._lastFrameTime = time;
    Tetris.cumulatedFrameTime += Tetris.frameTime;

    while (Tetris.cumulatedFrameTime > Tetris.gameStepTime) {
        Tetris.cumulatedFrameTime -= Tetris.gameStepTime;
        Tetris.Block.move(0, 0, -1);
    }

    //Tetris.renderer.render(Tetris.scene, Tetris.camera);
	// Render the scene.
	Tetris.effect.render(Tetris.scene, Tetris.camera);
    Tetris.stats.update();

//    if (!Tetris.gameOver) window.requestAnimationFrame(Tetris.animate);
	if (!Tetris.gameOver) Tetris.vrDisplay.requestAnimationFrame(Tetris.animate);
};


// nice test:
// var i = 0, j = 0, k = 0, interval = setInterval(function() {if(i==6) {i=0;j++;} if(j==6) {j=0;k++;} if(k==6) {clearInterval(interval); return;} Tetris.addStaticBlock(i,j,k); i++;},30)

Tetris.staticBlocks = [];
Tetris.zColors = [
    0x6666ff, 0x66ffff, 0xcc68EE, 0x666633, 0x66ff66, 0x9966ff, 0x00ff66, 0x66EE33, 0x003399, 0x330099, 0xFFA500, 0x99ff00, 0xee1289, 0x71C671, 0x00BFFF, 0x666633, 0x669966, 0x9966ff
];
Tetris.addStaticBlock = function (x, y, z) {
    if (Tetris.staticBlocks[x] === undefined) Tetris.staticBlocks[x] = [];
    if (Tetris.staticBlocks[x][y] === undefined) Tetris.staticBlocks[x][y] = [];

    var mesh = THREE.SceneUtils.createMultiMaterialObject(new THREE.CubeGeometry(Tetris.blockSize, Tetris.blockSize, Tetris.blockSize), [
        new THREE.MeshBasicMaterial({color:0x000000, shading:THREE.FlatShading, wireframe:true, transparent:true}),
        new THREE.MeshBasicMaterial({color:Tetris.zColors[z]})
    ]);

    mesh.position.x = (x - Tetris.boundingBoxConfig.splitX / 2) * Tetris.blockSize + Tetris.blockSize / 2;
    mesh.position.y = (y - Tetris.boundingBoxConfig.splitY / 2) * Tetris.blockSize + Tetris.blockSize / 2;
    mesh.position.z = (z - Tetris.boundingBoxConfig.splitZ / 2) * Tetris.blockSize + Tetris.blockSize / 2;

    Tetris.scene.add(mesh);
    Tetris.staticBlocks[x][y][z] = mesh;
};

Tetris.currentPoints = 0;
Tetris.addPoints = function (n) {
    Tetris.currentPoints += n;
    Tetris.pointsDOM.innerHTML = Tetris.currentPoints;
    Cufon.replace('#points');
    Tetris.sounds["score"].play();
};

window.addEventListener("load", Tetris.init);

window.addEventListener('keydown', function (event) {
    var key = event.which ? event.which : event.keyCode;

    switch (key) {
        //case

        case 38: // up (arrow)
            Tetris.Block.move(0, 1, 0);
            break;
        case 40: // down (arrow)
            Tetris.Block.move(0, -1, 0);
            break;
        case 37: // left(arrow)
            Tetris.Block.move(-1, 0, 0);
            break;
        case 39: // right (arrow)
            Tetris.Block.move(1, 0, 0);
            break;
        case 32: // space
            Tetris.Block.move(0, 0, -1);
            break;

        case 87: // up (w)
            Tetris.Block.rotate(90, 0, 0);
            break;
        case 83: // down (s)
            Tetris.Block.rotate(-90, 0, 0);
            break;

        case 65: // left(a)
            Tetris.Block.rotate(0, 0, 90);
            break;
        case 68: // right (d)
            Tetris.Block.rotate(0, 0, -90);
            break;

        case 81: // (q)
            Tetris.Block.rotate(0, 90, 0);
            break;
        case 69: // (e)
            Tetris.Block.rotate(0, -90, 0);
            break;
    }
}, false);	

//BKL




// Button click handlers.
document.querySelector('button#fullscreen').addEventListener('click', function() {
  enterFullscreen(Tetris.renderer.domElement);
});

document.querySelector('button#vr').addEventListener('click', function() {
  Tetris.vrDisplay.requestPresent([{source: Tetris.renderer.domElement}]);
});

function enterFullscreen (el) {
  if (el.requestFullscreen) {
    el.requestFullscreen();
  } else if (el.mozRequestFullScreen) {
    el.mozRequestFullScreen();
  } else if (el.webkitRequestFullscreen) {
    el.webkitRequestFullscreen();
  } else if (el.msRequestFullscreen) {
    el.msRequestFullscreen();
  }
}


</script>

</html>
